# [Linux kernel Scheduling and preemption](https://en.wikipedia.org/wiki/Linux_kernel#Scheduling_and_preemption)

- [Linux kernel Scheduling and preemption](#linux-kernel-scheduling-and-preemption)

The Linux scheduler is modular, in the sense that it enables different **scheduling classes** and **policies**. Scheduler classes are **plugable scheduler algorithms** that can be registered with the base scheduler code. **Each class schedules different types of processes**. The core code of the scheduler **iterates over each class** in order of priority and chooses the **highest priority scheduler** that has a **schedulable entity** of type **struct sched_entity** ready to run. Entities may be threads, group of threads, and even all the processes of a specific user.

Linux provides both user preemption as well as full kernel preemption. Preemption reduces latency, increases responsiveness, and makes Linux more suitable for desktop and real-time applications.

For **normal tasks**, by default, the kernel uses the **Completely Fair Scheduler (CFS) class**, introduced in the 2.6.23 version of the kernel. Internally this default-scheduler class is defined in a macro of a C header as `SCHED_NORMAL`. In other POSIX kernels, a similar policy known as `SCHED_OTHER` allocates CPU **timeslices** (i.e, it assigns absolute slices of the processor time depending on either predetermined or dynamically computed priority of each process). The Linux CFS does away with absolute timeslices and assigns a fair proportion of CPU time, as a function of parameters like the total number of runnable processes and the time they have already run; this function also takes into account a kind of **weight** that depends on their relative priorities (**nice values**).

With user preemption, the kernel scheduler can replace the current process with the execution of a context switch to a different one that therefore acquires the computing resources for running (CPU, memory, and more). It makes it according to the CFS algorithm (in particular, it uses a variable called `vruntime` for sorting entities and then chooses the one that has the smaller `vruntime`, - i.e., the schedulable entity that has had the least share of CPU time), to the active scheduler policy and to the relative priorities. With kernel preemption, the kernel can **preempt itself** when an **interrupt handler returns**, when **kernel tasks block**, and whenever a subsystem explicitly **calls the `schedule()`** function.

The kernel also contains two POSIX-compliant real-time scheduling classes named `SCHED_FIFO` (realtime first-in-first-out) and `SCHED_RR` (realtime round-robin), both of which **take precedence over the default class**. An additional scheduling policy known as `SCHED_DEADLINE`, implementing the earliest deadline first algorithm (EDF), was added in kernel version 3.14, released on 30 March 2014. `SCHED_DEADLINE` takes precedence over all the other scheduling classes.

The Linux kernel patch `PREEMPT_RT` enables full preemption of critical sections, interrupt handlers, and "interrupt disable" code sequences. Partial integration of the real-time Linux patches brought the above mentioned functionality to the kernel mainline.
